<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Fri Jul 03 09:23:43 CEST 2009 -->
<TITLE>
BaseService (JADE v3.7 API)
</TITLE>
<META NAME="keywords" CONTENT="jade.core.BaseService,BaseService class">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</HEAD>
<SCRIPT>
function asd()
{
parent.document.title="BaseService (JADE v3.7 API)";
}
</SCRIPT>
<BODY BGCOLOR="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/BaseService.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../jade/core/AID.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../jade/core/ContainerID.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="BaseService.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
jade.core</FONT>
<BR>
Class BaseService</H2>
<PRE>
java.lang.Object
  |
  +--<B>jade.core.BaseService</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../jade/core/Service.html">Service</A></DD>
</DL>
<HR>
<DL>
<DT>public abstract class <B>BaseService</B><DT>extends java.lang.Object<DT>implements <A HREF="../../jade/core/Service.html">Service</A></DL>

<P>
The <code>BaseService</code> abstract class partially implements
 the <code>Service</code> interface, providing a simple and uniform
 mechanism for slice management and service discovery.
 Developers interested in creating JADE kernel level services should
 extend <code>BaseService</code> instead of directly implementing the 
 <code>Service</code> interface
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>Giovanni Rimassa - FRAMeTech s.r.l.</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TD>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_jade.core.Service"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Nested classes inherited from class jade.core.<A HREF="../../jade/core/Service.html">Service</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../jade/core/Service.Slice.html">Service.Slice</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#MAIN_SLICE">MAIN_SLICE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../jade/core/ServiceFinder.html">ServiceFinder</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#myFinder">myFinder</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../jade/util/Logger.html">Logger</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#myLogger">myLogger</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#THIS_SLICE">THIS_SLICE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_jade.core.Service"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from interface jade.core.<A HREF="../../jade/core/Service.html">Service</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../jade/core/Service.html#ADOPTED_NODE">ADOPTED_NODE</A>, <A HREF="../../jade/core/Service.html#DEAD_NODE">DEAD_NODE</A>, <A HREF="../../jade/core/Service.html#DEAD_PLATFORM_MANAGER">DEAD_PLATFORM_MANAGER</A>, <A HREF="../../jade/core/Service.html#DEAD_REPLICA">DEAD_REPLICA</A>, <A HREF="../../jade/core/Service.html#DEAD_SLICE">DEAD_SLICE</A>, <A HREF="../../jade/core/Service.html#NEW_NODE">NEW_NODE</A>, <A HREF="../../jade/core/Service.html#NEW_REPLICA">NEW_REPLICA</A>, <A HREF="../../jade/core/Service.html#NEW_SLICE">NEW_SLICE</A>, <A HREF="../../jade/core/Service.html#REATTACHED">REATTACHED</A>, <A HREF="../../jade/core/Service.html#RECONNECTED">RECONNECTED</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#BaseService()">BaseService</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#addAlias(java.lang.String, java.lang.String)">addAlias</A></B>(java.lang.String&nbsp;alias,
         java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This protected method allows subclasses to define their own
         naming schemes, by adding aliases for existing slice names.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#boot(jade.core.Profile)">boot</A></B>(<A HREF="../../jade/core/Profile.html">Profile</A>&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs the active initialization step of a kernel-level
       service. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#clearCachedSlice(java.lang.String)">clearCachedSlice</A></B>(java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;CallbackInvokator</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#createInvokator()">createInvokator</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#dump(java.lang.String)">dump</A></B>(java.lang.String&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method can be redefined to support service internal data inspection by means of the ContainerMonitorAgent
 included in the misc add-on.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../jade/core/Service.Slice.html">Service.Slice</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#getAllSlices()">getAllSlices</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>getAllSlices()</code> implementation of this class
         directly retrieves the current list of slices from the Service
         Manager.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../jade/core/behaviours/Behaviour.html">Behaviour</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#getAMSBehaviour()">getAMSBehaviour</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This should be properly implemented
         by the services that require a service specific Behaviour 
         running in the AMS.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../jade/core/Filter.html">Filter</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#getCommandFilter(boolean)">getCommandFilter</A></B>(boolean&nbsp;direction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This should be properly implemented
         by the services that have filters.
         </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../jade/core/Sink.html">Sink</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#getCommandSink(boolean)">getCommandSink</A></B>(boolean&nbsp;direction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This should be properly implemented
         by the services that have sinks.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../jade/core/Service.Slice.html">Service.Slice</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#getFreshSlice(java.lang.String)">getFreshSlice</A></B>(java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../jade/core/ServiceHelper.html">ServiceHelper</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#getHelper(jade.core.Agent)">getHelper</A></B>(<A HREF="../../jade/core/Agent.html">Agent</A>&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This should be properly implemented
         by the services that have helpers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#getHorizontalInterface()">getHorizontalInterface</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This should be properly implemented
         by the services that have non-empty slices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;IMTPManager</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#getIMTPManager()">getIMTPManager</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../jade/core/Node.html">Node</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#getLocalNode()">getLocalNode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../jade/core/Service.Slice.html">Service.Slice</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#getLocalSlice()">getLocalSlice</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This should be properly implemented
         by the services that have non-empty slices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#getNumberOfSlices()">getNumberOfSlices</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method returns the current number of slices known to this
         service <b>on this node</b>. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#getOwnedCommands()">getOwnedCommands</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This should be properly implemented
         by the services that owns vertival commands.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../jade/core/Service.Slice.html">Service.Slice</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#getSlice(java.lang.String)">getSlice</A></B>(java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>getSlice()</code> implementation of this class works
         as follows:
         
         <i>First, the name alias table is used to convert the given
         slice name into another name, if any</i>
         
         <i>Then, the new name (which may or may not be different
         from the original one) is used to look up an internal table
         keeping the service slices</i>
         
         <i>If no slice was found, the</i>
         <code>ServiceFinder</code> <i>is asked to provide the slice,
         which is then put into the local table.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#init(jade.core.AgentContainer, jade.core.Profile)">init</A></B>(<A HREF="../../jade/core/AgentContainer.html">AgentContainer</A>&nbsp;ac,
     <A HREF="../../jade/core/Profile.html">Profile</A>&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs the passive initialization step of the service. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#lookupAlias(java.lang.String)">lookupAlias</A></B>(java.lang.String&nbsp;alias)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This protected method is used by <code>getSlice()</code> to
         dereference aliases for slice names. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#shutdown()">shutdown</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs the shutdown step of a kernel-level service.
       </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#stringifySlice(jade.core.Service.Slice)">stringifySlice</A></B>(<A HREF="../../jade/core/Service.Slice.html">Service.Slice</A>&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jade/core/BaseService.html#submit(jade.core.VerticalCommand)">submit</A></B>(<A HREF="../../jade/core/VerticalCommand.html">VerticalCommand</A>&nbsp;cmd)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allows submitting a vertical command for processing.
       </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_jade.core.Service"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from interface jade.core.<A HREF="../../jade/core/Service.html">Service</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../jade/core/Service.html#getName()">getName</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="MAIN_SLICE"><!-- --></A><H3>
MAIN_SLICE</H3>
<PRE>
public static final java.lang.String <B>MAIN_SLICE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jade.core.BaseService.MAIN_SLICE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="THIS_SLICE"><!-- --></A><H3>
THIS_SLICE</H3>
<PRE>
public static final java.lang.String <B>THIS_SLICE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#jade.core.BaseService.THIS_SLICE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="myFinder"><!-- --></A><H3>
myFinder</H3>
<PRE>
protected <A HREF="../../jade/core/ServiceFinder.html">ServiceFinder</A> <B>myFinder</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="myLogger"><!-- --></A><H3>
myLogger</H3>
<PRE>
protected transient <A HREF="../../jade/util/Logger.html">Logger</A> <B>myLogger</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="BaseService()"><!-- --></A><H3>
BaseService</H3>
<PRE>
public <B>BaseService</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="init(jade.core.AgentContainer, jade.core.Profile)"><!-- --></A><H3>
init</H3>
<PRE>
public void <B>init</B>(<A HREF="../../jade/core/AgentContainer.html">AgentContainer</A>&nbsp;ac,
                 <A HREF="../../jade/core/Profile.html">Profile</A>&nbsp;p)
          throws <A HREF="../../jade/core/ProfileException.html">ProfileException</A></PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../jade/core/Service.html">Service</A></CODE></B></DD>
<DD>Performs the passive initialization step of the service. This
       method is called <b>before</b> activating the service. Its role
       should be simply the one of a constructor, setting up the
       internal data as needed.
       Service implementations should not use the Service Manager and
       Service Finder facilities from within this method. A
       distributed initialization protocol, if needed, should be
       exectuted within the <code>boot()</code> method.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../jade/core/Service.html#init(jade.core.AgentContainer, jade.core.Profile)">init</A></CODE> in interface <CODE><A HREF="../../jade/core/Service.html">Service</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ac</CODE> - The agent container this service is activated on.<DD><CODE>p</CODE> - The configuration profile for this service.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../jade/core/ProfileException.html">ProfileException</A></CODE> - If the given profile is not valid.</DL>
</DD>
</DL>
<HR>

<A NAME="getSlice(java.lang.String)"><!-- --></A><H3>
getSlice</H3>
<PRE>
public <A HREF="../../jade/core/Service.Slice.html">Service.Slice</A> <B>getSlice</B>(java.lang.String&nbsp;name)
                       throws <A HREF="../../jade/core/ServiceException.html">ServiceException</A></PRE>
<DL>
<DD>The <code>getSlice()</code> implementation of this class works
         as follows:
         <ol>
         <li><i>First, the name alias table is used to convert the given
         slice name into another name, if any</i></li>
         
         <li><i>Then, the new name (which may or may not be different
         from the original one) is used to look up an internal table
         keeping the service slices</i></li>
         
         <li><i>If no slice was found, the</i>
         <code>ServiceFinder</code> <i>is asked to provide the slice,
         which is then put into the local table.</i></li>
         </ol>
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../jade/core/Service.html#getSlice(java.lang.String)">getSlice</A></CODE> in interface <CODE><A HREF="../../jade/core/Service.html">Service</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>name</CODE> - A name for the requested slice. The name must be
       unique within this service.
<DT><B>Returns:</B><DD>The <code>Slice<code> object that is a part of this
       service and is identified by the given name, or
       <code>null</code> if no such slice exists.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../jade/core/ServiceException.html">ServiceException</A></CODE> - If some underlying error (e.g. a
       network problem) occurs, that does not allow to decide whether
       the requested slice exists or not.</DL>
</DD>
</DL>
<HR>

<A NAME="getNumberOfSlices()"><!-- --></A><H3>
getNumberOfSlices</H3>
<PRE>
public int <B>getNumberOfSlices</B>()</PRE>
<DL>
<DD>This method returns the current number of slices known to this
         service <b>on this node</b>. Due to the distributed nature of
         many JADE services, there is no guaranteed that calling this
         method for the same service on different nodes will actually
         result on the same number.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../jade/core/Service.html#getNumberOfSlices()">getNumberOfSlices</A></CODE> in interface <CODE><A HREF="../../jade/core/Service.html">Service</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The number of slices of this service that are known to
         this node.</DL>
</DD>
</DL>
<HR>

<A NAME="getLocalNode()"><!-- --></A><H3>
getLocalNode</H3>
<PRE>
public <A HREF="../../jade/core/Node.html">Node</A> <B>getLocalNode</B>()
                  throws IMTPException</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DD><CODE>IMTPException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getAllSlices()"><!-- --></A><H3>
getAllSlices</H3>
<PRE>
public <A HREF="../../jade/core/Service.Slice.html">Service.Slice</A>[] <B>getAllSlices</B>()
                             throws <A HREF="../../jade/core/ServiceException.html">ServiceException</A></PRE>
<DL>
<DD>The <code>getAllSlices()</code> implementation of this class
         directly retrieves the current list of slices from the Service
         Manager.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../jade/core/Service.html#getAllSlices()">getAllSlices</A></CODE> in interface <CODE><A HREF="../../jade/core/Service.html">Service</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>An array of <code>Service.Slice</code> objects, whose
       elements are the slices of this service deployed at the
       different platform nodes.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../jade/core/ServiceException.html">ServiceException</A></CODE> - If some underlying error (e.g. a
       network problem) occurs, that does not allow to retrieve the
       full slice list.</DL>
</DD>
</DL>
<HR>

<A NAME="addAlias(java.lang.String, java.lang.String)"><!-- --></A><H3>
addAlias</H3>
<PRE>
protected void <B>addAlias</B>(java.lang.String&nbsp;alias,
                        java.lang.String&nbsp;name)</PRE>
<DL>
<DD>This protected method allows subclasses to define their own
         naming schemes, by adding aliases for existing slice names.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>alias</CODE> - The new alias name.<DD><CODE>name</CODE> - The real name this alias must be mapped to.</DL>
</DD>
</DL>
<HR>

<A NAME="lookupAlias(java.lang.String)"><!-- --></A><H3>
lookupAlias</H3>
<PRE>
protected java.lang.String <B>lookupAlias</B>(java.lang.String&nbsp;alias)</PRE>
<DL>
<DD>This protected method is used by <code>getSlice()</code> to
         dereference aliases for slice names. Subclasses can override
         this method to build their own service-specific naming schema.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>alias</CODE> - The alias name to map to a real slice name.
<DT><B>Returns:</B><DD>A mapped name, or the original one if no mapping was
         found.</DL>
</DD>
</DL>
<HR>

<A NAME="getCommandFilter(boolean)"><!-- --></A><H3>
getCommandFilter</H3>
<PRE>
public <A HREF="../../jade/core/Filter.html">Filter</A> <B>getCommandFilter</B>(boolean&nbsp;direction)</PRE>
<DL>
<DD>This should be properly implemented
         by the services that have filters.
         Note that when called multiple times with the same value of the <code>direction</code> 
         parameter this method MUST always return the same object!
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../jade/core/Service.html#getCommandFilter(boolean)">getCommandFilter</A></CODE> in interface <CODE><A HREF="../../jade/core/Service.html">Service</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>direction</CODE> - One of the two constants
       <code>Filter.INCOMING</code> and <code>Filter.OUTGOING</code>,
       distinguishing between the two filter chains managed by the
       command processor.
<DT><B>Returns:</B><DD>A <code>Filter</code> object, used by this service to
       intercept and process kernel-level commands. If the service
       does not wish to install a command filter for one or both
       directions, it can just return <code>null</code> when
       appropriate.<DT><B>See Also:</B><DD><CODE>jade.core.CommandProcessor</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getCommandSink(boolean)"><!-- --></A><H3>
getCommandSink</H3>
<PRE>
public <A HREF="../../jade/core/Sink.html">Sink</A> <B>getCommandSink</B>(boolean&nbsp;direction)</PRE>
<DL>
<DD>This should be properly implemented
         by the services that have sinks.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../jade/core/Service.html#getCommandSink(boolean)">getCommandSink</A></CODE> in interface <CODE><A HREF="../../jade/core/Service.html">Service</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>direction</CODE> - One of the two constants
       <code>Sink.COMMAND_SOURCE</code> or
       <code>Sink.COMMAND_TARGET</code>, to state whether this sink
       will handle locally issued commands or commands incoming from
       remote nodes.
<DT><B>Returns:</B><DD>Concrete services must return their own implementation
       of the <code>Sink</code> interface, that will be invoked by the
       kernel in order to consume any incoming vertical command owned
       by this service. If the service does not wish to install a
       command sink, it can just return <code>null</code>.<DT><B>See Also:</B><DD><A HREF="../../jade/core/Service.html#getOwnedCommands()"><CODE>Service.getOwnedCommands()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getOwnedCommands()"><!-- --></A><H3>
getOwnedCommands</H3>
<PRE>
public java.lang.String[] <B>getOwnedCommands</B>()</PRE>
<DL>
<DD>This should be properly implemented
         by the services that owns vertival commands.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../jade/core/Service.html#getOwnedCommands()">getOwnedCommands</A></CODE> in interface <CODE><A HREF="../../jade/core/Service.html">Service</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>An array containing the names of all the vertical
       commands this service wants to own. If this service has no such
       commands (it acts purely as a command filter), it can return an
       empty array, or <code>null</code> as well.<DT><B>See Also:</B><DD><CODE>jade.core.Service#getCommandSink()</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getHorizontalInterface()"><!-- --></A><H3>
getHorizontalInterface</H3>
<PRE>
public java.lang.Class <B>getHorizontalInterface</B>()</PRE>
<DL>
<DD>This should be properly implemented
         by the services that have non-empty slices.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../jade/core/Service.html#getHorizontalInterface()">getHorizontalInterface</A></CODE> in interface <CODE><A HREF="../../jade/core/Service.html">Service</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A <code>Class</code> object, representing the interface
       that is implemented by the slices of this service.  Let
       <code>s</code> be the <code>Class</code> object corresponding
       to the <code>Service.Slice</code> interface, and let
       <code>c</code> be the returned <code>Class</code> object. Then,
       the two following conditions must hold:
       <ol>
       <li><code>c.isInterface() == true</code></li>
       <li><code>s.isAssignableFrom(c) == true</code></li>
       </ol></DL>
</DD>
</DL>
<HR>

<A NAME="getLocalSlice()"><!-- --></A><H3>
getLocalSlice</H3>
<PRE>
public <A HREF="../../jade/core/Service.Slice.html">Service.Slice</A> <B>getLocalSlice</B>()</PRE>
<DL>
<DD>This should be properly implemented
         by the services that have non-empty slices.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../jade/core/Service.html#getLocalSlice()">getLocalSlice</A></CODE> in interface <CODE><A HREF="../../jade/core/Service.html">Service</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The slice of this service that resides on the local
       platform node, or <code>null</code> if no such slice exists.</DL>
</DD>
</DL>
<HR>

<A NAME="getHelper(jade.core.Agent)"><!-- --></A><H3>
getHelper</H3>
<PRE>
public <A HREF="../../jade/core/ServiceHelper.html">ServiceHelper</A> <B>getHelper</B>(<A HREF="../../jade/core/Agent.html">Agent</A>&nbsp;a)
                        throws <A HREF="../../jade/core/ServiceException.html">ServiceException</A></PRE>
<DL>
<DD>This should be properly implemented
         by the services that have helpers.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../jade/core/Service.html#getHelper(jade.core.Agent)">getHelper</A></CODE> in interface <CODE><A HREF="../../jade/core/Service.html">Service</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>a</CODE> - The agent which the helper is requested for.
<DT><B>Returns:</B><DD>The ServiceHelper to be used by the agent.
<DD><CODE><A HREF="../../jade/core/ServiceException.html">ServiceException</A></CODE><DT><B>See Also:</B><DD><CODE>AgentToolkit#getHelper</CODE>, 
<A HREF="../../jade/core/Agent.html#getHelper(java.lang.String)"><CODE>Agent.getHelper(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getAMSBehaviour()"><!-- --></A><H3>
getAMSBehaviour</H3>
<PRE>
public <A HREF="../../jade/core/behaviours/Behaviour.html">Behaviour</A> <B>getAMSBehaviour</B>()</PRE>
<DL>
<DD>This should be properly implemented
         by the services that require a service specific Behaviour 
         running in the AMS.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../jade/core/Service.html#getAMSBehaviour()">getAMSBehaviour</A></CODE> in interface <CODE><A HREF="../../jade/core/Service.html">Service</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A <code>Behaviour</code> object associated with this
       service, or <code>null</code> if no such behaviour exists.</DL>
</DD>
</DL>
<HR>

<A NAME="boot(jade.core.Profile)"><!-- --></A><H3>
boot</H3>
<PRE>
public void <B>boot</B>(<A HREF="../../jade/core/Profile.html">Profile</A>&nbsp;p)
          throws <A HREF="../../jade/core/ServiceException.html">ServiceException</A></PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../jade/core/Service.html">Service</A></CODE></B></DD>
<DD>Performs the active initialization step of a kernel-level
       service. When JADE kernel calls this method, the service has
       already been already associated with its container and
       registered with the Service Manager.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../jade/core/Service.html#boot(jade.core.Profile)">boot</A></CODE> in interface <CODE><A HREF="../../jade/core/Service.html">Service</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>p</CODE> - The configuration profile for this service.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../jade/core/ServiceException.html">ServiceException</A></CODE> - If a problem occurs during service
       initialization.</DL>
</DD>
</DL>
<HR>

<A NAME="shutdown()"><!-- --></A><H3>
shutdown</H3>
<PRE>
public void <B>shutdown</B>()</PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../jade/core/Service.html">Service</A></CODE></B></DD>
<DD>Performs the shutdown step of a kernel-level service.
       The JADE kernel calls this method just before uninstalling
       this service
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../jade/core/Service.html#shutdown()">shutdown</A></CODE> in interface <CODE><A HREF="../../jade/core/Service.html">Service</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="submit(jade.core.VerticalCommand)"><!-- --></A><H3>
submit</H3>
<PRE>
public java.lang.Object <B>submit</B>(<A HREF="../../jade/core/VerticalCommand.html">VerticalCommand</A>&nbsp;cmd)
                        throws <A HREF="../../jade/core/ServiceException.html">ServiceException</A></PRE>
<DL>
<DD><B>Description copied from interface: <CODE><A HREF="../../jade/core/Service.html">Service</A></CODE></B></DD>
<DD>Allows submitting a vertical command for processing.
       The given vertical command must be owned by this service
       (i.e. its name must be one of the constants contained in the
       array returned by <code>getOwnedCommands()</code>, or an
       exception is thrown
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../jade/core/Service.html#submit(jade.core.VerticalCommand)">submit</A></CODE> in interface <CODE><A HREF="../../jade/core/Service.html">Service</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cmd</CODE> - The command to submit to the service.
<DT><B>Returns:</B><DD>The result of the command, or <code>null</code> if this
       command produced no result. If an exception was produced, it
       will not be thrown, but will be returned as well.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../jade/core/ServiceException.html">ServiceException</A></CODE> - If the passed command does not belong
       to this service.</DL>
</DD>
</DL>
<HR>

<A NAME="getFreshSlice(java.lang.String)"><!-- --></A><H3>
getFreshSlice</H3>
<PRE>
protected <A HREF="../../jade/core/Service.Slice.html">Service.Slice</A> <B>getFreshSlice</B>(java.lang.String&nbsp;name)
                               throws <A HREF="../../jade/core/ServiceException.html">ServiceException</A></PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DD><CODE><A HREF="../../jade/core/ServiceException.html">ServiceException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getIMTPManager()"><!-- --></A><H3>
getIMTPManager</H3>
<PRE>
protected IMTPManager <B>getIMTPManager</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearCachedSlice(java.lang.String)"><!-- --></A><H3>
clearCachedSlice</H3>
<PRE>
protected void <B>clearCachedSlice</B>(java.lang.String&nbsp;name)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="dump(java.lang.String)"><!-- --></A><H3>
dump</H3>
<PRE>
public java.lang.String <B>dump</B>(java.lang.String&nbsp;key)</PRE>
<DL>
<DD>This method can be redefined to support service internal data inspection by means of the ContainerMonitorAgent
 included in the misc add-on.
 The default implementation just dumps the map of cached slices
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - A hint indicating which service data should be dumped
<DT><B>Returns:</B><DD>A string representation of the service internal data</DL>
</DD>
</DL>
<HR>

<A NAME="stringifySlice(jade.core.Service.Slice)"><!-- --></A><H3>
stringifySlice</H3>
<PRE>
public static final java.lang.String <B>stringifySlice</B>(<A HREF="../../jade/core/Service.Slice.html">Service.Slice</A>&nbsp;s)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createInvokator()"><!-- --></A><H3>
createInvokator</H3>
<PRE>
protected CallbackInvokator <B>createInvokator</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/BaseService.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../jade/core/AID.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../jade/core/ContainerID.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="BaseService.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<center>These are the official <i><a href=http://jade.tilab.com target=top>JADE</a></i> API. For these API backward compatibility is guaranteed accross JADE versions</center>
</BODY>
</HTML>
